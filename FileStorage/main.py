from flask import Flask, render_template, send_from_directory, request, abort, session, redirect
import bcrypt
import json
import os
import sqlite3
import uuid

app = Flask(__name__)

def create_users_database():
    '''
    Creates users database if it wasn't found during startup.
    The users database will contain only admin account with the password and username "admin".
    It is recommended that the password is changed before putting the site to production.
    '''
    conn = sqlite3.connect('users.db')
    cur = conn.cursor()
    cur.execute('''CREATE TABLE users (userID INTEGER PRIMARY KEY AUTOINCREMENT,
                                                                username TEXT NOT NULL UNIQUE,
                                                                password BLOB NOT NULL,
                                                                UUID TEXT NOT NULL UNIQUE,
                                                                permissions INTEGER NOT NULL DEFAULT 0);
                        ''')
    password = bcrypt.hashpw('admin'.encode('utf-8'), app.config['GENSALT'])
    admin_uuid = str(uuid.uuid4())
    cur.execute('INSERT INTO users (username, password, UUID, permissions) VALUES ("admin", ?, ?, 1)', (password, admin_uuid))
    cur.execute('''CREATE TABLE files (fileID INTEGER PRIMARY KEY AUTOINCREMENT,
                                                            publicFilename TEXT NOT NULL,
                                                            internalFilename TEXT NOT NULL UNIQUE,
                                                            userID INTEGER NOT NULL,
                                                            FOREIGN KEY(userID) REFERENCES users(USERID));
                        ''')
    conn.commit()
    cur.close()
    conn.close()
    if(not os.path.isdir(f'files/{admin_uuid}')):
        os.makedirs(f'files/{admin_uuid}')

def check_databases():
    if(not os.path.isfile('users.db')):
        create_users_database()

def set_configs():
    '''
    Loads data from config file if it exists.
    If it doesn't, it generates one.
    MAX_CONTENT_LENGTH_GB is set to 1 by default,
    salt for hashing passwords and secret key are generated by the bcrypt module.
    '''
    if(os.path.isfile('config.json')):
        app.config.from_file('config.json', load = json.load)
        app.config['GENSALT'] = app.config['GENSALT'].encode('utf-8')
        app.config['SECRET_KEY'] = app.config['SECRET_KEY'].encode('utf-8')
    else:
        app.config['MAX_FILE_SIZE_GB'] = 1
        app.config['GENSALT'] = bcrypt.gensalt()
        app.config['SECRET_KEY'] = bcrypt.gensalt()
        config_data = {
            'GENSALT': app.config['GENSALT'].decode(),
            'MAX_FILE_SIZE_GB': app.config['MAX_FILE_SIZE_GB'],
            'SECRET_KEY': app.config['SECRET_KEY'].decode()
            }
        with open('config.json', 'wt') as file:
            json.dump(config_data, file, indent = 1)
    app.config['MAX_CONTENT_LENGTH'] = app.config['MAX_FILE_SIZE_GB'] * 1024 * 1024 * 1024

def convert_bytes_to_megabytes(size:int) -> float:
    size_in_megabytes = round((size / (1024 * 1024)), 3)
    return size_in_megabytes

def get_file_list(username:str) -> dict:
    conn = sqlite3.connect('users.db')
    cur = conn.cursor()
    uuid = cur.execute('SELECT UUID FROM users WHERE username=?', (username, )).fetchall()[0][0]
    file_list = cur.execute('SELECT publicFilename, internalFilename FROM files INNER JOIN users ON files.userID=users.userID WHERE username=?', (username, )).fetchall()
    file_list = dict(
        (file[0], convert_bytes_to_megabytes(os.path.getsize(f'files/{uuid}/{file[1]}')))
                 for file in file_list)
    cur.close()
    conn.close()
    return file_list

@app.errorhandler(500)
def internal_server_error(e):
    msg = "Internal Server Error: something went wrong when processing your request."
    return render_template('error.html', msg = msg), 500

@app.errorhandler(413)
def request_entity_too_large(e):
    plural = 's' if app.config['MAX_FILE_SIZE_GB'] != 1 else ''
    msg = f"Requested Entity Too Large: you cannot upload files larger than {app.config['MAX_FILE_SIZE_GB']} gigabyte{plural}."
    return render_template('file_upload.html', status = msg, saved = False), 413

@app.errorhandler(404)
def page_not_found(e):
    msg = "Page Not Found: requested page couldn't be found."
    return render_template('error.html', msg = msg), 404

@app.errorhandler(401)
def unauthorized(e):
    msg = "Unauthorized: you need to log in to view this page."
    return render_template('error.html', msg = msg), 401

@app.route('/favicon.ico')
def send_favicon():
    return send_from_directory('static', 'favicon.ico')

@app.route('/style.css')
def send_css():
    return send_from_directory('static', 'style.css')

@app.route('/robots.txt')
def send_robots_txt():
    return send_from_directory('static', 'robots.txt')

@app.route('/upload', methods = ['GET', 'POST'])
def upload_file_page():
    if(not session.get('username')):
        abort(401)
    if(request.method == 'POST'):
        username = session.get('username')
        file = request.files['file']
        filename = file.filename
        if(filename == ''):
            return render_template('file_upload.html', status = 'Failed to save the file: no file found.', saved = False)
        conn = sqlite3.connect('users.db')
        cur = conn.cursor()
        noOfFiles = cur.execute('''SELECT COUNT(*)
                                            FROM files INNER JOIN users ON users.userID=files.userID
                                            WHERE publicFilename=? AND username=?''',
                                            (filename, username)).fetchall()[0][0]
        if(noOfFiles > 0):
            conn.commit()
            cur.close()
            return render_template('file_upload.html', status = "Couldn't save the file: file with such name already exists.", saved = False)
        results = cur.execute('SELECT userID, UUID FROM users WHERE username=? LIMIT 1', (username, ))
        uploader_id, uploader_UUID = results.fetchall()[0]
        internal_name = str(uuid.uuid4())
        file.save(f'files/{uploader_UUID}/{internal_name}')
        cur.execute('INSERT INTO files (publicFilename, internalFilename, userID) VALUES (?, ?, ?)', (filename, internal_name, uploader_id))
        conn.commit()
        cur.close()
        conn.close()
        return render_template('file_upload.html', status = 'File has been saved on the server.', saved = True)
    return render_template('file_upload.html')

@app.route('/download/<file>')
def send_file(file):
    if(not session.get('username')):
        return redirect('/login')
    username = session.get('username')
    conn = sqlite3.connect('users.db')
    cur = conn.cursor()
    internalFilename, UUID = cur.execute('''SELECT internalfilename, UUID
                                                    FROM users
                                                    INNER JOIN files
                                                    ON users.userID=files.userID
                                                    WHERE publicFilename=?
                                                    AND username=?''',
                                            (file, username)).fetchall()[0]
    cur.close()
    conn.close()
    if(os.path.isfile(f"files/{UUID}/{internalFilename}")):
        return send_from_directory(f'files/{UUID}', internalFilename, download_name = file, as_attachment = True)
    else:
        abort(404)

@app.route('/download')
def download_file_page():
    if(not session.get('username')):
        abort(401)
    username = session.get('username')
    files = get_file_list(username)
    return render_template("file_download.html", files = files, number_of_files = len(files))

@app.route('/login', methods = ['GET', 'POST'])
def login():
    if(session.get('username')):
        return redirect('/')
    if(request.method == 'POST'):
        username = request.form.get('username')
        password = request.form.get('password')
        password = bcrypt.hashpw(password.encode('utf-8'), app.config['GENSALT'])
        conn = sqlite3.connect('users.db')
        cur = conn.cursor()
        results = cur.execute('SELECT username FROM users WHERE username=? AND password=? LIMIT 1', (username, password))
        username_list = results.fetchall()
        if(len(username_list) == 0):
            return render_template('login.html', success = False)
        username = username_list[0][0]
        cur.close()
        conn.close()
        session['username'] = username
        return redirect('/')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('username', None)
    return redirect('/')

@app.route('/')
def index():
    return render_template('index.html')

def start_website():
    set_configs()
    check_databases()
    app.run()

if(__name__ == "__main__"):
    start_website()
